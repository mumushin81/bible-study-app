/**
 * ë™ê¸°í™” í ê´€ë¦¬
 * ì˜¤í”„ë¼ì¸ì—ì„œ ì‘ì—…í•œ ë‚´ìš©ì„ ì˜¨ë¼ì¸ ë³µê·€ ì‹œ ì„œë²„ì™€ ë™ê¸°í™”
 */

import { supabase } from './supabase';
import {
  db,
  getSyncQueue,
  removeSyncQueueItem,
  incrementSyncRetry,
  addToSyncQueue,
  SyncQueueItem,
  getUnsyncedProgress,
  markProgressSynced
} from './offlineStorage';

// ============================================
// Sync Queue í´ë˜ìŠ¤
// ============================================

class SyncQueueManager {
  private isSyncing = false;
  private readonly MAX_RETRIES = 3;

  /**
   * íì— ì‘ì—… ì¶”ê°€
   */
  async add(
    table: string,
    operation: 'INSERT' | 'UPDATE' | 'DELETE',
    data: any
  ): Promise<void> {
    await addToSyncQueue(table, operation, data);

    // ì˜¨ë¼ì¸ì´ë©´ ì¦‰ì‹œ ë™ê¸°í™” ì‹œë„
    if (navigator.onLine) {
      await this.sync();
    }
  }

  /**
   * ì „ì²´ ë™ê¸°í™” ì‹¤í–‰
   */
  async sync(): Promise<void> {
    if (this.isSyncing || !navigator.onLine) {
      console.log('â­ï¸ Sync skipped:', { isSyncing: this.isSyncing, online: navigator.onLine });
      return;
    }

    this.isSyncing = true;
    console.log('ğŸ”„ Starting sync...');

    try {
      // 1. Sync Queue ì²˜ë¦¬
      await this.processSyncQueue();

      // 2. User Progress ë™ê¸°í™”
      await this.syncUserProgress();

      console.log('âœ… Sync completed successfully');
    } catch (error) {
      console.error('âŒ Sync failed:', error);
    } finally {
      this.isSyncing = false;
    }
  }

  /**
   * Sync Queueì˜ ëª¨ë“  í•­ëª© ì²˜ë¦¬
   */
  private async processSyncQueue(): Promise<void> {
    const queue = await getSyncQueue();

    for (const item of queue) {
      try {
        // ìµœëŒ€ ì¬ì‹œë„ íšŸìˆ˜ ì´ˆê³¼ ì‹œ ìŠ¤í‚µ
        if (item.retries >= this.MAX_RETRIES) {
          console.warn(`âš ï¸ Max retries exceeded for item ${item.id}, removing from queue`);
          await removeSyncQueueItem(item.id);
          continue;
        }

        await this.syncItem(item);
        await removeSyncQueueItem(item.id);
        console.log(`âœ… Synced item: ${item.table} ${item.operation}`);
      } catch (error) {
        console.error(`âŒ Failed to sync item ${item.id}:`, error);
        await incrementSyncRetry(item.id);
      }
    }
  }

  /**
   * ê°œë³„ í•­ëª© ë™ê¸°í™”
   */
  private async syncItem(item: SyncQueueItem): Promise<void> {
    const { table, operation, data } = item;

    switch (operation) {
      case 'INSERT':
      case 'UPDATE':
        await supabase.from(table).upsert(data);
        break;

      case 'DELETE':
        await supabase.from(table).delete().eq('id', data.id);
        break;

      default:
        throw new Error(`Unknown operation: ${operation}`);
    }
  }

  /**
   * User Progress ë™ê¸°í™”
   */
  private async syncUserProgress(): Promise<void> {
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) return;

    const unsyncedProgress = await getUnsyncedProgress(user.id);

    for (const progress of unsyncedProgress) {
      try {
        const { error } = await supabase
          .from('user_progress')
          .upsert({
            user_id: progress.user_id,
            verse_id: progress.verse_id,
            completed: progress.completed,
            completed_at: progress.completed_at,
            review_count: progress.review_count,
            last_reviewed_at: progress.last_reviewed_at
          }, {
            onConflict: 'user_id,verse_id'
          });

        if (error) throw error;

        await markProgressSynced(progress.id);
        console.log(`âœ… Synced progress: ${progress.verse_id}`);
      } catch (error) {
        console.error(`âŒ Failed to sync progress for ${progress.verse_id}:`, error);
      }
    }
  }

  /**
   * íŠ¹ì • í…Œì´ë¸”ì˜ ë°ì´í„° ê°•ì œ ë™ê¸°í™”
   */
  async forceSync(table: string): Promise<void> {
    console.log(`ğŸ”„ Force syncing table: ${table}`);
    const queue = await getSyncQueue();
    const items = queue.filter(item => item.table === table);

    for (const item of items) {
      try {
        await this.syncItem(item);
        await removeSyncQueueItem(item.id);
      } catch (error) {
        console.error(`Failed to force sync item ${item.id}:`, error);
      }
    }
  }

  /**
   * ì¶©ëŒ í•´ê²° - Last Write Wins
   */
  async resolveConflict(localData: any, serverData: any): Promise<any> {
    const localTime = new Date(localData.updated_at).getTime();
    const serverTime = new Date(serverData.updated_at).getTime();

    if (localTime > serverTime) {
      // ë¡œì»¬ì´ ë” ìµœì‹ : ì„œë²„ì— ì—…ë¡œë“œ
      console.log('ğŸ”„ Local data is newer, uploading to server');
      return localData;
    } else {
      // ì„œë²„ê°€ ë” ìµœì‹ : ë¡œì»¬ ì—…ë°ì´íŠ¸
      console.log('ğŸ“¥ Server data is newer, updating local');
      return serverData;
    }
  }

  /**
   * ì¶©ëŒ í•´ê²° - Merge (review_count ë“±)
   */
  mergeProgress(local: any, server: any): any {
    return {
      ...server,
      completed: local.completed || server.completed,
      review_count: Math.max(local.review_count || 0, server.review_count || 0),
      last_reviewed_at: new Date(
        Math.max(
          new Date(local.last_reviewed_at || 0).getTime(),
          new Date(server.last_reviewed_at || 0).getTime()
        )
      ).toISOString()
    };
  }
}

// ì‹±ê¸€í†¤ ì¸ìŠ¤í„´ìŠ¤
export const syncQueue = new SyncQueueManager();

// ============================================
// ì˜¨ë¼ì¸/ì˜¤í”„ë¼ì¸ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
// ============================================

if (typeof window !== 'undefined') {
  window.addEventListener('online', () => {
    console.log('ğŸ“¶ Back online, starting sync...');
    syncQueue.sync();
  });

  window.addEventListener('offline', () => {
    console.log('ğŸ“´ Gone offline');
  });

  // í˜ì´ì§€ ë¡œë“œ ì‹œ ìë™ ë™ê¸°í™”
  window.addEventListener('load', () => {
    if (navigator.onLine) {
      setTimeout(() => {
        syncQueue.sync();
      }, 1000);
    }
  });
}

// ============================================
// Service Worker ë©”ì‹œì§€ í•¸ë“¤ëŸ¬
// ============================================

if (typeof navigator !== 'undefined' && 'serviceWorker' in navigator) {
  navigator.serviceWorker.addEventListener('message', (event) => {
    if (event.data.type === 'SYNC_REQUIRED') {
      console.log('ğŸ“¨ Sync requested by service worker');
      syncQueue.sync();
    }
  });
}
