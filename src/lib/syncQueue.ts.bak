/**
 * 동기화 큐 관리
 * 오프라인에서 작업한 내용을 온라인 복귀 시 서버와 동기화
 */

import { supabase } from './supabase';
import {
  db,
  getSyncQueue,
  removeSyncQueueItem,
  incrementSyncRetry,
  addToSyncQueue,
  SyncQueueItem,
  getUnsyncedProgress,
  markProgressSynced
} from './offlineStorage';

// ============================================
// Sync Queue 클래스
// ============================================

class SyncQueueManager {
  private isSyncing = false;
  private readonly MAX_RETRIES = 3;

  /**
   * 큐에 작업 추가
   */
  async add(
    table: string,
    operation: 'INSERT' | 'UPDATE' | 'DELETE',
    data: any
  ): Promise<void> {
    await addToSyncQueue(table, operation, data);

    // 온라인이면 즉시 동기화 시도
    if (navigator.onLine) {
      await this.sync();
    }
  }

  /**
   * 전체 동기화 실행
   */
  async sync(): Promise<void> {
    if (this.isSyncing || !navigator.onLine) {
      console.log('⏭️ Sync skipped:', { isSyncing: this.isSyncing, online: navigator.onLine });
      return;
    }

    this.isSyncing = true;
    console.log('🔄 Starting sync...');

    try {
      // 1. Sync Queue 처리
      await this.processSyncQueue();

      // 2. User Progress 동기화
      await this.syncUserProgress();

      console.log('✅ Sync completed successfully');
    } catch (error) {
      console.error('❌ Sync failed:', error);
    } finally {
      this.isSyncing = false;
    }
  }

  /**
   * Sync Queue의 모든 항목 처리
   */
  private async processSyncQueue(): Promise<void> {
    const queue = await getSyncQueue();

    for (const item of queue) {
      try {
        // 최대 재시도 횟수 초과 시 스킵
        if (item.retries >= this.MAX_RETRIES) {
          console.warn(`⚠️ Max retries exceeded for item ${item.id}, removing from queue`);
          await removeSyncQueueItem(item.id);
          continue;
        }

        await this.syncItem(item);
        await removeSyncQueueItem(item.id);
        console.log(`✅ Synced item: ${item.table} ${item.operation}`);
      } catch (error) {
        console.error(`❌ Failed to sync item ${item.id}:`, error);
        await incrementSyncRetry(item.id);
      }
    }
  }

  /**
   * 개별 항목 동기화
   */
  private async syncItem(item: SyncQueueItem): Promise<void> {
    const { table, operation, data } = item;

    switch (operation) {
      case 'INSERT':
      case 'UPDATE':
        await supabase.from(table).upsert(data);
        break;

      case 'DELETE':
        await supabase.from(table).delete().eq('id', data.id);
        break;

      default:
        throw new Error(`Unknown operation: ${operation}`);
    }
  }

  /**
   * User Progress 동기화
   */
  private async syncUserProgress(): Promise<void> {
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) return;

    const unsyncedProgress = await getUnsyncedProgress(user.id);

    for (const progress of unsyncedProgress) {
      try {
        const { error } = await supabase
          .from('user_progress')
          .upsert({
            user_id: progress.user_id,
            verse_id: progress.verse_id,
            completed: progress.completed,
            completed_at: progress.completed_at,
            review_count: progress.review_count,
            last_reviewed_at: progress.last_reviewed_at
          }, {
            onConflict: 'user_id,verse_id'
          });

        if (error) throw error;

        await markProgressSynced(progress.id);
        console.log(`✅ Synced progress: ${progress.verse_id}`);
      } catch (error) {
        console.error(`❌ Failed to sync progress for ${progress.verse_id}:`, error);
      }
    }
  }

  /**
   * 특정 테이블의 데이터 강제 동기화
   */
  async forceSync(table: string): Promise<void> {
    console.log(`🔄 Force syncing table: ${table}`);
    const queue = await getSyncQueue();
    const items = queue.filter(item => item.table === table);

    for (const item of items) {
      try {
        await this.syncItem(item);
        await removeSyncQueueItem(item.id);
      } catch (error) {
        console.error(`Failed to force sync item ${item.id}:`, error);
      }
    }
  }

  /**
   * 충돌 해결 - Last Write Wins
   */
  async resolveConflict(localData: any, serverData: any): Promise<any> {
    const localTime = new Date(localData.updated_at).getTime();
    const serverTime = new Date(serverData.updated_at).getTime();

    if (localTime > serverTime) {
      // 로컬이 더 최신: 서버에 업로드
      console.log('🔄 Local data is newer, uploading to server');
      return localData;
    } else {
      // 서버가 더 최신: 로컬 업데이트
      console.log('📥 Server data is newer, updating local');
      return serverData;
    }
  }

  /**
   * 충돌 해결 - Merge (review_count 등)
   */
  mergeProgress(local: any, server: any): any {
    return {
      ...server,
      completed: local.completed || server.completed,
      review_count: Math.max(local.review_count || 0, server.review_count || 0),
      last_reviewed_at: new Date(
        Math.max(
          new Date(local.last_reviewed_at || 0).getTime(),
          new Date(server.last_reviewed_at || 0).getTime()
        )
      ).toISOString()
    };
  }
}

// 싱글톤 인스턴스
export const syncQueue = new SyncQueueManager();

// ============================================
// 온라인/오프라인 이벤트 리스너
// ============================================

if (typeof window !== 'undefined') {
  window.addEventListener('online', () => {
    console.log('📶 Back online, starting sync...');
    syncQueue.sync();
  });

  window.addEventListener('offline', () => {
    console.log('📴 Gone offline');
  });

  // 페이지 로드 시 자동 동기화
  window.addEventListener('load', () => {
    if (navigator.onLine) {
      setTimeout(() => {
        syncQueue.sync();
      }, 1000);
    }
  });
}

// ============================================
// Service Worker 메시지 핸들러
// ============================================

if (typeof navigator !== 'undefined' && 'serviceWorker' in navigator) {
  navigator.serviceWorker.addEventListener('message', (event) => {
    if (event.data.type === 'SYNC_REQUIRED') {
      console.log('📨 Sync requested by service worker');
      syncQueue.sync();
    }
  });
}
