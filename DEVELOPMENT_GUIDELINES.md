# Eden App 개발 지침서

## 📋 목차
1. [코드 수정 원칙](#코드-수정-원칙)
2. [요구사항 분석](#요구사항-분석)
3. [UI/UX 개발 가이드](#uiux-개발-가이드)
4. [반복 발생한 문제와 해결책](#반복-발생한-문제와-해결책)
5. [체크리스트](#체크리스트)

---

## 🎯 코드 수정 원칙

### 1. 기존 기능 보존
**문제점**: 새로운 기능을 추가하거나 버그를 수정하는 과정에서 기존에 작동하던 기능까지 삭제하는 경우가 발생

**개선 방안**:
- ✅ 수정 전 해당 컴포넌트의 **전체 기능 목록** 작성
- ✅ 수정 후 **기존 기능이 모두 유지**되는지 확인
- ✅ 코드 삭제 시 **주석으로 먼저 처리**하고 테스트 후 삭제
- ✅ Git diff 확인하여 의도하지 않은 삭제가 없는지 검토

**실제 사례**:
```
❌ 나쁜 예:
- 깊이읽기 섹션을 수정하면서 openCommentary state까지 삭제
- 결과: 아코디언 기능 전체가 사라짐

✅ 좋은 예:
- 깊이읽기 렌더링을 수정하되 openCommentary state 유지
- 기존 아코디언 기능 보존
```

### 2. 최소 변경 원칙
**문제점**: 작은 문제를 해결하기 위해 불필요하게 많은 코드를 수정

**개선 방안**:
- ✅ 문제의 **근본 원인**만 정확히 수정
- ✅ 영향 범위를 최소화
- ✅ 리팩토링은 별도로 진행

**실제 사례**:
```typescript
// ❌ 나쁜 예: 텍스트 오버플로우 문제를 해결하기 위해 전체 레이아웃 변경
<div className="complete-restructure">...</div>

// ✅ 좋은 예: 해당 요소만 수정
<div className="existing-layout">
  <p style={{ fontSize: 'clamp(0.7rem, 2.2vw, 0.85rem)' }}>
    {text}
  </p>
</div>
```

---

## 🔍 요구사항 분석

### 1. 명확한 의도 파악
**문제점**: 사용자의 요구사항을 표면적으로만 이해하고 작업

**개선 방안**:
- ✅ **왜(Why)** 이 변경이 필요한지 질문
- ✅ 사용자가 **진짜 원하는 것**이 무엇인지 확인
- ✅ 애매한 표현은 **구체적인 예시** 요청

**실제 사례**:
```
사용자: "색감 표시 제거하고 단어장 모두 가운데 정렬하자"

❌ 내 해석: 모든 색상 제거 → 파스텔 디자인까지 삭제
✅ 올바른 해석: 품사별 색상 코딩만 제거, 파스텔 글라스모피즘은 유지

→ 질문했어야 할 것: "파스텔 배경색도 제거할까요, 아니면 품사별 색상만 제거할까요?"
```

### 2. 대안 제시
**문제점**: 사용자가 제시한 방법이 최선이 아닐 수 있음

**개선 방안**:
- ✅ 문제 해결을 위한 **여러 대안** 제시
- ✅ 각 대안의 **장단점** 설명
- ✅ 사용자와 함께 **최적의 방법** 선택

**실제 사례**:
```
사용자: "스크롤 기능 추가해줘"

❌ 나쁜 응답: 즉시 스크롤 추가
✅ 좋은 응답:
  "오버플로우 문제 해결 방법으로 3가지 대안이 있습니다:
   1. 세로 스크롤 추가 (간단하지만 UX 저하)
   2. 폰트 크기 축소 (가독성 저하 가능)
   3. 반응형 폰트 (clamp 사용) (권장)
   어떤 방법을 선호하시나요?"
```

---

## 🎨 UI/UX 개발 가이드

### 1. 반응형 디자인 우선
**원칙**: 스크롤이나 고정 크기보다는 **반응형 디자인**을 우선 고려

**권장 방법**:
```css
/* ❌ 피해야 할 패턴 */
.element {
  font-size: 14px;
  overflow-y: auto;
  max-height: 400px;
}

/* ✅ 권장 패턴 */
.element {
  font-size: clamp(0.7rem, 2.2vw, 0.85rem);
  padding: clamp(0.5rem, 2vw, 1rem);
  /* 스크롤 없이 화면 크기에 맞게 조절 */
}
```

**적용 사례**:
- 플래시카드 뒷면: 스크롤 → 반응형 폰트로 변경
- 현대어역 카드: 가로 스크롤 → 멀티라인 + word-break로 변경

### 2. 레이아웃 우선순위
**우선순위**:
1. 반응형 크기 조절 (clamp, vw, vh)
2. Flexbox/Grid 자동 레이아웃
3. 내용 축약/생략 (text-overflow: ellipsis)
4. 스크롤 (최후의 수단)

### 3. 디자인 일관성
**원칙**:
- ✅ 같은 요소는 **동일한 스타일** 적용
- ✅ 색상, 간격, 폰트 크기 **패턴 유지**
- ✅ 다크모드 양쪽 모두 고려

**스타일 가이드**:
```typescript
// 파스텔 글라스모피즘 패턴 (일관성 유지)
const glassmorphismStyle = {
  light: 'bg-gradient-to-br from-purple-50/80 via-pink-50/80 to-blue-50/80',
  dark: 'bg-gradient-to-br from-purple-900/40 via-pink-900/40 to-blue-900/40',
  backdrop: {
    backdropFilter: 'blur(20px)',
    WebkitBackdropFilter: 'blur(20px)',
  }
};

// 반응형 폰트 크기 패턴
const fontSizes = {
  title: 'clamp(1rem, 4vw, 1.5rem)',
  body: 'clamp(0.75rem, 2.5vw, 0.9rem)',
  caption: 'clamp(0.6rem, 2vw, 0.75rem)',
};
```

---

## 🔧 반복 발생한 문제와 해결책

### 문제 1: 깊이읽기 기능 반복 수정
**발생 횟수**: 3회

**타임라인**:
1. 렌더링 불완전 → whyQuestion, conclusion 추가
2. 섹션 전체 삭제 → 섹션 재추가
3. 아코디언 기능 삭제 → 아코디언 재추가

**근본 원인**:
- 전체 구조 파악 없이 부분만 수정
- 기존 기능 확인 없이 코드 삭제

**해결책**:
```typescript
// ✅ 수정 전 체크리스트
// 1. Commentary 인터페이스 확인
// 2. 렌더링해야 할 모든 섹션 목록 작성:
//    - intro
//    - sections (color cards)
//    - whyQuestion
//    - conclusion
// 3. 기존 state 확인 (openCommentary)
// 4. 수정 후 모든 섹션이 표시되는지 확인
```

### 문제 2: 텍스트 오버플로우 처리
**발생 횟수**: 4회

**시도한 방법들**:
1. 멀티라인 (break-words) → 사용자가 한 줄 요청
2. 가로 스크롤 → 스와이프 충돌
3. stopPropagation() 추가 → 여전히 UX 문제
4. 최종: 멀티라인 + 적절한 word-break ✅

**교훈**:
- 첫 번째 시도에서 사용자에게 여러 옵션 제시했다면 반복 수정 방지 가능
- 스크롤은 최후의 수단

**올바른 접근**:
```markdown
사용자: "현대어의역 카드 문장들이 짤리는 현상"

✅ 제안해야 했던 대안:
1. 멀티라인으로 표시 (권장)
   - 장점: 모든 내용 표시, 자연스러운 읽기
   - 단점: 카드 높이 증가

2. 한 줄 + 가로 스크롤
   - 장점: 카드 높이 유지
   - 단점: 스와이프 제스처 충돌 가능

3. 한 줄 + 말줄임표
   - 장점: 간결함
   - 단점: 전체 내용 확인 불가

어떤 방법을 선호하시나요?
```

### 문제 3: 플래시카드 오버플로우
**발생 횟수**: 3회

**시도한 방법들**:
1. 스크롤 추가 → 사용자가 스크롤 원하지 않음
2. 폰트 크기만 축소 → 여전히 오버플로우
3. 최종: 스크롤 제거 + 전체적 반응형 폰트 ✅

**교훈**:
- 처음부터 반응형 디자인 고려했다면 1회에 해결 가능
- 모든 요소(이모지, 의미, 발음, 어근, 문법, 구조)의 크기를 함께 고려

---

## ✅ 작업 전 체크리스트

### 코드 수정 전
- [ ] 사용자 요구사항의 **진짜 의도** 파악
- [ ] 현재 코드의 **전체 구조** 파악
- [ ] 수정할 부분과 **영향 범위** 확인
- [ ] 기존 **기능 목록** 작성
- [ ] 여러 **해결 방안** 검토

### 코드 수정 중
- [ ] **최소한의 변경**으로 문제 해결
- [ ] 기존 기능 **보존** 확인
- [ ] 다크모드/라이트모드 **양쪽** 테스트
- [ ] 다양한 **화면 크기**에서 테스트
- [ ] 주석으로 **의도** 명확히 표시

### 코드 수정 후
- [ ] 요구사항이 **정확히 구현**되었는지 확인
- [ ] **기존 기능**이 모두 작동하는지 확인
- [ ] **부작용**이 없는지 확인
- [ ] 코드 **일관성** 유지 확인
- [ ] 사용자에게 **결과 설명** 및 **대안 제시**

---

## 🎯 핵심 원칙 요약

### 1. 이해 우선 (Understand First)
> "빠르게 코딩하기 전에, 천천히 이해하라"
- 요구사항의 근본 의도 파악
- 현재 코드 전체 구조 이해
- 영향 범위 사전 분석

### 2. 최소 변경 (Minimal Change)
> "필요한 만큼만, 정확하게"
- 문제의 근본 원인만 수정
- 불필요한 리팩토링 자제
- 영향 범위 최소화

### 3. 기능 보존 (Preserve Features)
> "새로운 것을 추가할 때, 기존 것을 잃지 마라"
- 기존 기능 목록 작성
- 수정 후 기능 확인
- 의도하지 않은 삭제 방지

### 4. 반응형 우선 (Responsive First)
> "스크롤보다는 반응형으로"
- clamp()를 활용한 유연한 크기
- Flexbox/Grid 자동 레이아웃
- 스크롤은 최후의 수단

### 5. 대안 제시 (Suggest Alternatives)
> "하나의 방법이 아닌, 여러 선택지를"
- 3가지 이상 대안 제시
- 각 방법의 장단점 설명
- 사용자와 함께 결정

---

## 📚 참고 자료

### 사용된 기술 스택
- **React 18** + TypeScript
- **Framer Motion** - 애니메이션
- **Tailwind CSS** - 스타일링
- **CSS clamp()** - 반응형 폰트

### 디자인 패턴
- **Glassmorphism** - 유리 느낌의 반투명 효果
- **Pastel Colors** - 부드러운 파스텔 색상
- **Responsive Typography** - 화면 크기에 따른 폰트 조절

### 유용한 CSS 패턴
```css
/* 반응형 폰트 크기 */
font-size: clamp(최소값, 선호값, 최대값);

/* 글라스모피즘 */
backdrop-filter: blur(20px);
background: rgba(255, 255, 255, 0.1);

/* 한국어 자연스러운 줄바꿈 */
word-break: keep-all;

/* IPA 발음 기호 줄바꿈 */
word-break: break-all;
```

---

## 🔄 버전 히스토리
- v1.0 (2025-10-15): 초기 지침서 작성
  - 깊이읽기, 텍스트 오버플로우, 플래시카드 오버플로우 문제 분석
  - 개선 원칙 및 체크리스트 작성
